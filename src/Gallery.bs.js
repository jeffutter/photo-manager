// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Css from "../node_modules/bs-css-emotion/src/Css.js";
import * as List from "../node_modules/bs-platform/lib/es6/list.js";
import * as $$Array from "../node_modules/bs-platform/lib/es6/array.js";
import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as React from "react";
import * as ReactVirtualized from "react-virtualized";
import * as Utils$PhotoManager from "./Utils.bs.js";
import * as Debouncer$PhotoManager from "./Debouncer.bs.js";
import * as PhotoSwipe$PhotoManager from "./PhotoSwipe.bs.js";
import * as BreadCrumbs$PhotoManager from "./BreadCrumbs.bs.js";
import * as GalleryBody$PhotoManager from "./GalleryBody.bs.js";

function splitDescendants(_param, _descendants) {
  while(true) {
    var param = _param;
    var descendants = _descendants;
    var images = param[1];
    var thumbedImageSlugs = param[0];
    if (descendants) {
      var descendant = descendants[0];
      var rest = descendants[1];
      if (descendant[0] >= 121710777) {
        _descendants = rest;
        _param = /* tuple */[
          thumbedImageSlugs,
          images
        ];
        continue ;
      } else {
        var image = descendant[1];
        var match = image.thumbnail;
        _descendants = rest;
        if (match !== undefined) {
          _param = /* tuple */[
            /* :: */[
              image.slug,
              thumbedImageSlugs
            ],
            /* :: */[
              image,
              images
            ]
          ];
          continue ;
        } else {
          _param = /* tuple */[
            thumbedImageSlugs,
            /* :: */[
              image,
              images
            ]
          ];
          continue ;
        }
      }
    } else {
      return /* tuple */[
              List.rev(thumbedImageSlugs),
              List.rev(images)
            ];
    }
  };
}

function openLightboxFunc(send, thumbedImageSlugs, slug) {
  var index = $$Array.of_list(thumbedImageSlugs).indexOf(slug);
  return Curry._1(send, /* OpenLightbox */[index]);
}

var pending = {
  contents: /* [] */0
};

var loadPending = Debouncer$PhotoManager.make(200, (function (loadNextPage) {
        var list = pending.contents;
        if (list) {
          pending.contents = /* [] */0;
          var chunks = Utils$PhotoManager.chunkList(20, list);
          List.iter((function (chunk) {
                  return Curry._1(loadNextPage, $$Array.of_list(chunk));
                }), chunks);
          return /* () */0;
        } else {
          return /* () */0;
        }
      }));

function addToPending(loadNextPage, slug) {
  pending.contents = /* :: */[
    slug,
    pending.contents
  ];
  return Curry._1(loadPending, loadNextPage);
}

function Gallery(Props) {
  var nameOpt = Props.name;
  var pathOpt = Props.path;
  var slugOpt = Props.slug;
  var descendantsOpt = Props.descendants;
  var loadNextPage = Props.loadNextPage;
  var name = nameOpt !== undefined ? nameOpt : "";
  var path = pathOpt !== undefined ? pathOpt : [];
  var slug = slugOpt !== undefined ? slugOpt : "";
  var descendants = descendantsOpt !== undefined ? descendantsOpt : [];
  var match = React.useReducer((function (_state, action) {
          if (action) {
            return {
                    lightboxIsOpen: true,
                    currentImage: action[0]
                  };
          } else {
            return {
                    lightboxIsOpen: false,
                    currentImage: 0
                  };
          }
        }), {
        lightboxIsOpen: false,
        currentImage: 0
      });
  var dispatch = match[1];
  var state = match[0];
  var match$1 = splitDescendants(/* tuple */[
        /* [] */0,
        /* [] */0
      ], $$Array.to_list(descendants));
  var thumbedImageSlugs = match$1[0];
  var openLightbox = function (param) {
    return openLightboxFunc(dispatch, thumbedImageSlugs, param);
  };
  var loadImage = function (slug) {
    var slugHasThumb = List.exists((function (imageSlug) {
            return slug === imageSlug;
          }), thumbedImageSlugs);
    if (slugHasThumb) {
      return /* () */0;
    } else {
      addToPending(loadNextPage, slug);
      return /* () */0;
    }
  };
  var swipeImages = $$Array.of_list(List.map((function (image) {
              return {
                      src: image.largeUrl,
                      msrc: image.smallUrl,
                      w: image.width,
                      h: image.height,
                      title: image.name
                    };
            }), match$1[1]));
  var swipeOptions = {
    index: state.currentImage
  };
  var showPhotoSwipe = swipeImages.length !== 0;
  return React.createElement(ReactVirtualized.WindowScroller, {
              children: (function (scrollerOptions) {
                  return React.createElement("div", {
                              className: Curry._1(Css.style, /* :: */[
                                    Css.position(/* relative */903134412),
                                    /* :: */[
                                      Css.height(Css.pct(100.0)),
                                      /* [] */0
                                    ]
                                  ])
                            }, React.createElement(BreadCrumbs$PhotoManager.make, {
                                  path: path,
                                  slug: slug,
                                  name: name
                                }), React.createElement(GalleryBody$PhotoManager.make, {
                                  descendants: descendants,
                                  openLightbox: openLightbox,
                                  loadImage: loadImage,
                                  windowHeight: scrollerOptions.height,
                                  isScrolling: scrollerOptions.isScrolling,
                                  onScroll: scrollerOptions.onChildScroll,
                                  scrollTop: scrollerOptions.scrollTop
                                }), showPhotoSwipe ? React.createElement(PhotoSwipe$PhotoManager.make, {
                                    isOpen: state.lightboxIsOpen,
                                    items: swipeImages,
                                    onClose: (function (_event) {
                                        return Curry._1(dispatch, /* CloseLightbox */0);
                                      }),
                                    options: swipeOptions
                                  }) : React.createElement("div", undefined));
                })
            });
}

var make = Gallery;

export {
  splitDescendants ,
  openLightboxFunc ,
  pending ,
  loadPending ,
  addToPending ,
  make ,
  
}
/* loadPending Not a pure module */
