// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as Belt_Option from "../node_modules/bs-platform/lib/es6/belt_Option.js";
import * as Caml_option from "../node_modules/bs-platform/lib/es6/caml_option.js";

function makeCancelable(waitOpt, fn) {
  var wait = waitOpt !== undefined ? waitOpt : 100;
  var timerId = {
    contents: undefined
  };
  var lastArg = {
    contents: undefined
  };
  var lastCallTime = {
    contents: undefined
  };
  var shouldInvoke = function (time) {
    var match = lastCallTime.contents;
    if (match !== undefined) {
      var timeSinceLastCall = time - match | 0;
      if (timeSinceLastCall >= wait) {
        return true;
      } else {
        return timeSinceLastCall < 0;
      }
    } else {
      return true;
    }
  };
  var remainingWait = function (time) {
    var match = lastCallTime.contents;
    if (match !== undefined) {
      var timeSinceLastCall = time - match | 0;
      return wait - timeSinceLastCall | 0;
    } else {
      return wait;
    }
  };
  var timerExpired = function (param) {
    var match = timerId.contents;
    if (match !== undefined) {
      clearTimeout(Caml_option.valFromOption(match));
    }
    var time = Date.now() | 0;
    if (shouldInvoke(time)) {
      var x = lastArg.contents;
      if (x !== undefined) {
        lastArg.contents = undefined;
        timerId.contents = undefined;
        return Curry._1(fn, Caml_option.valFromOption(x));
      } else {
        timerId.contents = undefined;
        return /* () */0;
      }
    } else {
      timerId.contents = Caml_option.some(setTimeout(timerExpired, remainingWait(time)));
      return /* () */0;
    }
  };
  var schedule = function (x) {
    var time = Date.now() | 0;
    lastArg.contents = Caml_option.some(x);
    lastCallTime.contents = time;
    timerId.contents = Caml_option.some(setTimeout(timerExpired, wait));
    return /* () */0;
  };
  var scheduled = function (param) {
    return Belt_Option.isSome(timerId.contents);
  };
  var cancel = function (param) {
    var match = timerId.contents;
    if (match !== undefined) {
      clearTimeout(Caml_option.valFromOption(match));
      timerId.contents = undefined;
      lastArg.contents = undefined;
      lastCallTime.contents = undefined;
      return /* () */0;
    } else {
      return /* () */0;
    }
  };
  var now = function (x) {
    cancel(/* () */0);
    return Curry._1(fn, x);
  };
  return {
          invoke: now,
          schedule: schedule,
          scheduled: scheduled,
          cancel: cancel
        };
}

function make(wait, fn) {
  return makeCancelable(wait, fn).schedule;
}

export {
  makeCancelable ,
  make ,
  
}
/* No side effect */
